package ro.croco.integration.dms.toolkit;

import ro.croco.integration.dms.commons.FileUtils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/*
 * Created by Lucian.Dragomir on 8/13/2014.
 *
 * aceasta componenta calculeaza medatadele necesare operatiilor de storcare sau de mutare a documentlor in document management systems prin StoreService API
 *
 *
 *
 * tabela
 *
 *      storeServiceName, tipDocument, pathTemplate, fileName, SQLTemplate
 *      JCR, CerereRambursre, /Documents/Proiecte/Dosar{$SMIS}/CerereRambursare, CerereRambursare{$data}.pdf, "SELECT columnSMIS AS "SMIS", alte atribute FROM CERERE_RAMBURSARE WHERE Id = {$Id}"
 *
 *
 *      BO-JMS, /.........
 *
 *      pathTemplate - velocity template /Documents/Proiecte/Dosar{$SMIS}/CerereRambursare
 *      fileTemplate - velocity template CerereRambursare{$data}.pdf
 *      SQLTemplate - obtin metadatele pe ccare le mapez pe document ... si le folosesc pentru replacement de param in template
 *
 *
 *
 *
 *

 presupunem ca orice document adaugat in JCR are urmatoarele atribute:
 1. frontUserName - userul logat in FrontOffice
 2. documentType  - tipul documentului uploadat - de ex. "CerereFinantare", "CerereRambursare", "Facturi", .....
 3. documentKey	 - contine unul/un set de valori pentru a face legatura documentului cu datele din tabele (de ex. id-ul cererii de rambursare); va fi folosit ulterior pentru adaugarea automata a metadatelor (folosind StoreMetadata...)

 TODO - trebuie modificat nodul "mix:FileAttributes"	din clasa JcrRegisterCustomNodetypes



CREATE TABLE DMSUTILS_REPOSITORIES
        (
        STORE_SERVICE_NAME VARCHAR(100),
        REPOSITORY_NAME VARCHAR(100),
        PRIMARY KEY (STORE_SERVICE_NAME)
        );

        INSERT INTO DMSUTILS_REPOSITORIES (STORE_SERVICE_NAME, REPOSITORY_NAME)
        VALUES ('JCR-FO', 'JCR');
        INSERT INTO DMSUTILS_REPOSITORIES (STORE_SERVICE_NAME, REPOSITORY_NAME)
        VALUES ('CMIS-BO', 'ELO');
        INSERT INTO DMSUTILS_REPOSITORIES (STORE_SERVICE_NAME, REPOSITORY_NAME)
        VALUES ('JMS-FO', 'ELO');


        CREATE TABLE DMSUTILS_PROPERTIES (
        --ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, NO MINVALUE, NO MAXVALUE, NO CYCLE, NO ORDER),
        OBJECT_CODE VARCHAR(255) NOT NULL, -- will be the mask name of the object
        OBJECT_TYPE VARCHAR(50) NOT NULL, -- can be 'FOLDER' or 'DOCUMENT'
        REPOSITORY_NAME_DESTINATION VARCHAR(100) NOT NULL,
        OPERATION_NAME VARCHAR(255) NOT NULL, -- can be STORE OR MOVE
        REPOSITORY_NAME_SOURCE VARCHAR(100) NOT NULL,
        OBJECT_FOLDER_TEMPLATE VARCHAR(1000) NOT NULL,
        OBJECT_NAME_TEMPLATE VARCHAR(255) NOT NULL,
        OBJECT_MASK VARCHAR(255) NOT NULL,
        OBJECT_VERSIONING VARCHAR(50) NOT NULL,
        OBJECT_PROPERTIES_CONNECTION VARCHAR(50),
        OBJECT_PROPERTIES_SQL VARCHAR(4000),
        OBJECT_PRIORITY INT DEFAULT 1000,
        PRIMARY KEY (OBJECT_CODE, OBJECT_TYPE, STORE_SERVICE_DESTINATION, STORE_SERVICE_CONTEXT, STORE_SERVICE_SOURCE)
        )

        INSERT INTO DMSUTILS_PROPERTIES  (OBJECT_CODE, OBJECT_TYPE, REPOSITORY_NAME_DESTINATION, OPERATION_NAME, REPOSITORY_NAME_SOURCE, OBJECT_FOLDER_TEMPLATE, OBJECT_NAME_TEMPLATE, OBJECT_MASK, OBJECT_PROPERTIES_CONNECTION, OBJECT_PROPERTIES_SQL)
        VALUES('CerereRambursare', 'DOCUMENT', 'JCR', 'STORE', 'N/A', '/Proiecte/Dosar$SMIS/Cerere Rambursare/', 'CerereRambursare', 'mix:fileAttributes', NULL, NULL);
        INSERT INTO DMSUTILS_PROPERTIES  (OBJECT_CODE, OBJECT_TYPE, REPOSITORY_NAME_DESTINATION, OPERATION_NAME, REPOSITORY_NAME_SOURCE, OBJECT_FOLDER_TEMPLATE, OBJECT_NAME_TEMPLATE, OBJECT_MASK, OBJECT_PROPERTIES_CONNECTION, OBJECT_PROPERTIES_SQL)
        VALUES('CerereRambursare', 'DOCUMENT', 'ELO', 'STORE', 'N/A', '/Proiecte/Dosar$SMIS/Cerere Rambursare/', 'CerereRambursare', 'cmis:CerereRambursare', 'jndi/FrontOfficeDatabase', 'SELECT smisCode AS "SMIS", \'$\' ');

*/

public interface MetadataService extends InitableService {
    static final FileUtils fileUtils = new FileUtils("/", "/");

    public static final String RULE_DEFAULT = "DEFAULT";
    public static final String RULE_STORE_DEFAULT = "STORE";
    public static final String RULE_MOVE_DEFAULT = "MOVE";

    public static final String STORE_SERVICE_NA = "N/A";


    public static class Metadata<T extends ObjectInfo> {
        private T info;
        private VersioningType versioningType;
        private boolean allowCreatePath;

        private ObjectIdentifier sourceIdentifier;

        public Metadata() {
            allowCreatePath = false;
        }

        public T getInfo() {
            return info;
        }

        public void setInfo(T info) {
            this.info = info;
        }

        public VersioningType getVersioningType() {
            return versioningType;
        }

        public void setVersioningType(VersioningType versioningType) {
            this.versioningType = versioningType;
        }

        public boolean isAllowCreatePath() {
            return allowCreatePath;
        }

        public void setAllowCreatePath(boolean allowCreatePath) {
            this.allowCreatePath = allowCreatePath;
        }

        public ObjectIdentifier getSourceIdentifier() {
            return sourceIdentifier;
        }

        public void setSourceIdentifier(ObjectIdentifier sourceIdentifier) {
            this.sourceIdentifier = sourceIdentifier;
        }

        @Override
        public String toString() {
            return "Metadata{" +
                    "info=" + info +
                    ", versioningType=" + versioningType +
                    ", allowCreatePath=" + allowCreatePath +
                    ", sourceIdentifier=" + sourceIdentifier +
                    '}';
        }
    }


    public static class MetadataProperty {
        private static String HIDDEN_PLACEHOLDER = "_";
        private final boolean visible;
        private final String name;
        private Object value;

        private String getRealPropertyName(String propertyName) {
            if (propertyName == null) {
                return null;
            } else if (propertyName.startsWith(HIDDEN_PLACEHOLDER)) {
                return propertyName.substring(1);
            } else {
                return propertyName;
            }
        }

        private boolean getRealPropertyVisible(String propertyName) {
            if (propertyName == null) {
                return false;
            }
            return !propertyName.startsWith(HIDDEN_PLACEHOLDER);
        }

        public MetadataProperty() {
            this.visible = false;
            this.name = null;
            this.value = null;
        }

        public MetadataProperty(String name, Object value) {
            this.name = getRealPropertyName(name);
            this.value = value;
            this.visible = getRealPropertyVisible(name);
        }

        public MetadataProperty(MetadataPropertySpecial metadataPropertySpecial, Object value) {
            this(metadataPropertySpecial.toString(), value);
        }

        public MetadataProperty(String name, Object value, boolean visible) {
            this.name = getRealPropertyName(name);
            this.value = value;
            this.visible = visible;
        }

        public String getName() {
            return name;
        }

        public Object getValue() {
            return value;
        }

        public void setValue(Object value) {
            this.value = value;
        }

        public boolean isVisible() {
            return visible;
        }

        @Override
        public String toString() {
            return "MetadataProperty{" +
                    "visible=" + visible +
                    ", name='" + name + '\'' +
                    ", value=" + value +
                    '}';
        }
    }

    public static enum MetadataPropertySpecial {
        Code("objectCode"),
        Context("objectContext"),
        Name("objectName"),
        Extension("documentExtension"),
        VersioningType("objectVersioningType"),
        User("objectUserName");

        private String value;

        private MetadataPropertySpecial(String value) {
            this.value = value;
        }

        public boolean equalsValue(String otherValue) {
            return (otherValue == null) ? false : value.equals(otherValue);
        }

        public String toString() {
            return this.value;
        }
    }

    public static class MetadataProperties {
        Map<String, MetadataProperty> propertyMap;

        public static class Builder {
            private MetadataProperties object;

            public Builder() {
                object = new MetadataProperties();
            }

            public Builder withCode(String code) {
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.Code, code));
                return this;
            }

            public Builder withContext(String context) {
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.Context, context));
                return this;
            }

            public Builder withName(String name) {
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.Name, name));
                return this;
            }

            public Builder withExtension(String extension) {
                //!!extension face overwrite peste extension-ul din file-name-ul din proprietatea name
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.Extension, extension));
                return this;
            }

            public Builder withVersioningType(VersioningType versioningType) {
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.VersioningType, versioningType.name()));
                return this;
            }

            public Builder withUser(String user) {
                object.setMetadataProperty(new MetadataProperty(MetadataPropertySpecial.User, user));
                return this;
            }

            public Builder withProperty(String propertyName, Object propertyValue, boolean visible) {
                object.setMetadataProperty(new MetadataProperty(propertyName, propertyValue, visible));
                return this;
            }

            public Builder withProperty(String propertyName, Object propertyValue) {
                object.setMetadataProperty(new MetadataProperty(propertyName, propertyValue));
                return this;
            }

            public MetadataProperties build() {
                return object;
            }
        }

        public static Builder builder() {
            return new Builder();
        }


        public MetadataProperties() {
            this.propertyMap = new HashMap<String, MetadataProperty>();
        }

        public MetadataProperties(Properties properties) {
            this.propertyMap = new HashMap<String, MetadataProperty>();
            for (String propertyName : properties.keySet().toArray(new String[0])) {
                this.setMetadataProperty(new MetadataProperty(propertyName, properties.get(propertyName)));
            }
        }

        public MetadataProperties(Map<String, Object> properties) {
            this.propertyMap = new HashMap<String, MetadataProperty>();
            for (String propertyName : properties.keySet().toArray(new String[0])) {
                this.setMetadataProperty(new MetadataProperty(propertyName, properties.get(propertyName)));
            }
        }

        public MetadataProperty getMetadataProperty(MetadataPropertySpecial metadataPropertySpecial) {
            return this.getMetadataProperty(metadataPropertySpecial.toString());
        }

        public MetadataProperty getMetadataProperty(String propertyName) {
            return this.propertyMap.get(propertyName);
        }

        public void setMetadataProperty(MetadataProperty property) {
            this.propertyMap.put(property.getName(), property);
        }

        public MetadataProperty[] getProperties() {
            return this.propertyMap.values().toArray(new MetadataProperty[0]);
        }

        public Properties getAsPproperties() {
            Properties properties = new Properties();
            for (MetadataProperty metadataProperty : this.getProperties()) {
                if (metadataProperty.getValue() != null) {
                    properties.put(metadataProperty.getName(), metadataProperty.getValue());
                }
            }
            return properties;
        }

        public Map<String, Object> getAsMap() {
            return getAsMap(null);
        }

        public Map<String, Object> getAsMap(Boolean visible) {
            Map<String, Object> map = new HashMap<String, Object>();
            for (MetadataProperty metadataProperty : this.getProperties()) {
                if (visible == null || visible == metadataProperty.isVisible()) {
                    map.put(metadataProperty.getName(), metadataProperty.getValue());
                }
            }
            return map;
        }

        @Override
        public String toString() {
            return "MetadataProperties{" +
                    "propertyMap=" + propertyMap +
                    '}';
        }
    }

    public List<String> getDocumentsSupportedForStore(StoreService storeServiceDestination, StoreContext storeContextDestination);

    public Metadata<DocumentInfo> computeDocumentMetadata(StoreService storeServiceDestination, StoreContext storeContextDestination, MetadataProperties metadataProperties);

    public Metadata<DocumentInfo> computeDocumentMetadata(String documentCode, String documentContext, StoreService storeServiceDestination, StoreContext storeContextDestination, Properties properties);

    public Metadata<DocumentInfo> computeDocumentMetadata(DocumentIdentifier documentIdentifierSource, StoreService storeServiceSource, StoreContext storeContextSource, StoreService storeServiceDestination, StoreContext storeContextDestination);

    public Metadata<FolderInfo> computeFolderMetadata(StoreService storeServiceDestination, StoreContext storeContextDestination, MetadataProperties metadataProperties);

    public Metadata<FolderInfo> computeFolderMetadata(String folderCode, String folderContext, StoreService storeServiceDestination, StoreContext storeContextDestination, Properties properties);

    public List<Metadata<? extends ObjectInfo>> computeGroupMetadata(String groupCode, StoreService storeServiceDestination, StoreContext storeContextDestination, Properties properties);

}
